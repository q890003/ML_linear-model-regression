# -*- coding: utf-8 -*-
"""0856148_ML_hw1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fKLu1TsOpjBVgO6M3IIfvbT4_8iShE8E
"""

import numpy as np
import matplotlib.pyplot as plt

file = np.loadtxt('/content/testfile.txt', dtype=np.float, delimiter=',')

number_base = int(input('number of bases n=?'))
landa = int(input('landa=?'))

A = np.zeros( (file.shape[0],number_base) , dtype=np.float)
real_X = np.zeros( (file.shape[0]) , dtype=np.float)
real_Y = np.zeros( (file.shape[0]) , dtype=np.float)
for i in range(file.shape[0]):
    for j in range(number_base):
        A[i][j] = file[i][0]**(number_base-j-1)
        real_X[i] = file[i][0]
        real_Y[i] = file[i][1]

"""LSE Algorithm:"""

"""LU"""
AtA = A.T.dot(A) 
L = np.zeros((AtA.shape),dtype=np.float)
Element = np.zeros((AtA.shape),dtype=float)
AtA += + landa*Element
for i in range(L.shape[0]):
    L[i][i] = 1
    Element[i][i] = 1
#print(AtA)
U = AtA.copy()
for j in range(AtA.shape[0] - 1):
    for i in range(AtA.shape[0]-1 - j):
        #print('round', j, ':', i+j+1)
        if AtA[i+j+1][j] != 0 :
            Element[i+j+1][j]  =  -1 * U[i+j+1][j]/U[j][j]
            L[i+j+1][j] =       U[i+j+1][j]/U[j][j]
            U = Element.dot(U)
            Element[i+j+1][j] = 0
#print(L, '#l')
#print(U, '#u')
#print(L.dot(U), '#check if L dot U == AtA')

"""get inverse of AtA"""
"""
LU dot x = [1,0,0],[0,1,0],[0,0,1]  to get inverse of AtA
let U dot x = z = [z1,z2,z3]
=>L dot z = [1,0,0] ,z1=1
"""
AtA_inv = np.zeros(0, dtype=float)
for i in range(L.shape[0]):
    y = np.zeros((L.shape[0]),dtype=float)
    y[i] = 1
    z = np.linalg.solve(L, y.T)
    x = np.linalg.solve(U, z)
    AtA_inv = np.append(AtA_inv, x, axis = 0)
AtA_inv = np.reshape(AtA_inv, (AtA.shape)).T
#print(AtA_inv,'#AtA_inv')

"""get coef_x and error"""
LSE_coef_x = AtA_inv.dot(A.T).dot(real_Y)
#print(LSE_coef_x,'#coeffect_function')
LSE_approx_ans = A.dot(LSE_coef_x)
LSE_error = np.sum ( ((LSE_approx_ans - real_Y)**2) )


"""Newton method
#supose intial value x_old = [1,1,...,1]
x_new = x_old - H_inv dot delta_f     
(one dim example: x_new = x_old - f'(x)/f''(x))
"""

"""H, H_L, H_U
in here, objective function is power 2, 
just a case that H is AtA without dotting x
"""
Newton_coef = np.ones((A.shape[1]),dtype=float) 
x_old = np.zeros((A.shape[1]),dtype=float) 

while np.sum( (x_old - Newton_coef)**2 ) > 0.01:
    x_old = Newton_coef.copy()
    H = 2 * A.T.dot(A)
    H_L = Element.copy() #element size equal AtA
    H_U = H.copy()
    """ H = L dot U,  derive H_L, H_U """
    for j in range(H.shape[0] - 1):
        for i in range(H.shape[0]-1 - j):
            if H_U[i+j+1][j] != 0 :
                Element[i+j+1][j] = (-1)*H_U[i+j+1][j]/H_U[j][j]
                H_L[i+j+1][j] = H_U[i+j+1][j]/H_U[j][j]
                H_U = Element.dot(H_U)
                Element[i+j+1][j] = 0
    #H_inv
    H_inv = np.zeros(0, dtype=float)
    for i in range(H_L.shape[0]):
        y = np.zeros((H_L.shape[0]),dtype=float)
        y[i] = 1
        z = np.linalg.solve(H_L, y.T)
        x = np.linalg.solve(H_U, z)
        H_inv = np.append(H_inv, x, axis = 0)
    H_inv = np.reshape(H_inv, (H.shape)).T
    ##print(np.linalg.inv(H), 'inverse_true\n', H_inv)
    """delta_f = 2AtAx - 2Atb
    """
    delta_f = 2 * A.T.dot(A).dot(x_old) - 2 * A.T.dot(real_Y)
    """get coef_x and error
    x_new = x0 - H_inv dot delta_f
    """
    
    Newton_coef = x_old - H_inv.dot(delta_f)
    #print(Newton_coef,'#Newton_coef')

Newton_approx_ans = A.dot(Newton_coef)
newton_error = np.sum ((Newton_approx_ans - real_Y)**2 )

print('LSE:\nFitting line: ',end='')
for i in range(A.shape[1]-1):
    print("%fX^%d +" %(LSE_coef_x[i],A.shape[1]-1 - i),end=' ')
    if i == A.shape[1]-2:
        print(LSE_coef_x[A.shape[1]-1])
print('Total error: ', LSE_error)


print('Newton\'s Method:\nFitting line: ',end='')
for i in range(A.shape[1]-1):
    print("%fX^%d +" %(Newton_coef[i],A.shape[1]-1 - i),end=' ')
    if i == A.shape[1]-2:
        print(Newton_coef[A.shape[1]-1])
print('Total error: ', newton_error)


plt.sca( plt.subplot(2,1,1) )
plt.plot(real_X,real_Y,'ro')
plt.plot(real_X,LSE_approx_ans)
plt.sca( plt.subplot(2,1,2) )
plt.plot(real_X,real_Y,'ro')
plt.plot(real_X,Newton_approx_ans)